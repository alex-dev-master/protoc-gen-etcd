package main

import (
	"flag"
	ipb "github.com/alex-dev-master/protoc-gen-etcd/pkg/proto"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"log"
	"log/slog"
	"os"
)

var flags flag.FlagSet

type (
	Config struct {
		LogLevelDebug *bool
	}
)

func main() {
	cfg := Config{
		LogLevelDebug: flags.Bool("logLevelDebug", false, "enable debug log level"),
	}

	opts := protogen.Options{
		ParamFunc: flags.Set,
	}

	opts.Run(func(plugin *protogen.Plugin) error {
		logLevel := slog.LevelInfo
		if *cfg.LogLevelDebug {
			logLevel = slog.LevelDebug
		}

		textHandler := slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
			AddSource: false,
			Level:     logLevel,
			ReplaceAttr: func(groups []string, a slog.Attr) slog.Attr {
				if a.Key == slog.TimeKey {
					return slog.Attr{}
				}
				return a
			},
		})
		slog.SetDefault(slog.New(textHandler))

		slog.Info("Protogen plugin called with following files to be generated", "files", plugin.Request.FileToGenerate)
		slog.Debug("Protogen plugin called with following files to be generated", "files", plugin.Request.FileToGenerate)

		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}

			g := plugin.NewGeneratedFile(file.GeneratedFilenamePrefix+".etcd.go", file.GoImportPath)
			generateHeader(g, file)

			for _, message := range file.Messages {
				etcdKeyTemplate := getEtcdKeyTemplate(message)
				if etcdKeyTemplate == "" {
					log.Printf("Пропущено сообщение %s, так как etcd_key_template не задано\n", message.GoIdent.GoName)
					continue
				}
				generateEtcdClient(g, message, etcdKeyTemplate)
				generateEtcdServer(g, message, etcdKeyTemplate)
			}
		}
		return nil
	})
}

// generateHeader создает стандартный заголовок файла
func generateHeader(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by protoc-gen-etcd. DO NOT EDIT.")
	g.P("package ", file.GoPackageName)
	g.P(`import (`)
	g.P(`"context"`)
	g.P(`"go.etcd.io/etcd/client/v3"`)
	g.P(`"fmt"`)
	g.P(`"time"`)
	g.P(`)`)
}

// generateEtcdClient генерирует код клиента etcd
func generateEtcdClient(g *protogen.GeneratedFile, message *protogen.Message, etcdKeyTemplate string) {
	g.P("// ", message.GoIdent.GoName, "EtcdClient предоставляет методы для работы с etcd")
	g.P("type ", message.GoIdent.GoName, "EtcdClient struct {")
	g.P("    client *clientv3.Client")
	g.P("}")

	g.P("func New", message.GoIdent.GoName, "EtcdClient(endpoint string) (*", message.GoIdent.GoName, "EtcdClient, error) {")
	g.P("    cli, err := clientv3.New(clientv3.Config{")
	g.P("        Endpoints:   []string{endpoint},")
	g.P("        DialTimeout: 5 * time.Second,")
	g.P("    })")
	g.P("    if err != nil {")
	g.P("        return nil, err")
	g.P("    }")
	g.P("    return &", message.GoIdent.GoName, "EtcdClient{client: cli}, nil")
	g.P("}")

	g.P("func (c *", message.GoIdent.GoName, "EtcdClient) Put(ctx context.Context, m *", message.GoIdent.GoName, ") error {")
	g.P("    key := c.generateKey(m)")
	g.P("    _, err := c.client.Put(ctx, key, m.String())")
	g.P("    return err")
	g.P("}")

	g.P("func (c *", message.GoIdent.GoName, "EtcdClient) Get(ctx context.Context, id string) (*", message.GoIdent.GoName, ", error) {")
	g.P("    key := fmt.Sprintf(\"", etcdKeyTemplate, "\", id)")
	g.P("    resp, err := c.client.Get(ctx, key)")
	g.P("    if err != nil {")
	g.P("        return nil, err")
	g.P("    }")
	g.P("    if len(resp.Kvs) == 0 {")
	g.P("        return nil, fmt.Errorf(\"ключ не найден\")")
	g.P("    }")
	g.P("    return &", message.GoIdent.GoName, "{/* распарсить значение */}, nil")
	g.P("}")

	g.P("func (c *", message.GoIdent.GoName, "EtcdClient) generateKey(m *", message.GoIdent.GoName, ") string {")
	g.P("    return fmt.Sprintf(\"", etcdKeyTemplate, "\", m.Id)")
	g.P("}")
}

// generateEtcdServer генерирует код сервера etcd
func generateEtcdServer(g *protogen.GeneratedFile, message *protogen.Message, etcdKeyTemplate string) {
	g.P("// ", message.GoIdent.GoName, "EtcdServer предоставляет методы сервера для работы с etcd")
	g.P("type ", message.GoIdent.GoName, "EtcdServer struct {")
	g.P("    client *clientv3.Client")
	g.P("}")

	g.P("func New", message.GoIdent.GoName, "EtcdServer(endpoint string) (*", message.GoIdent.GoName, "EtcdServer, error) {")
	g.P("    cli, err := clientv3.New(clientv3.Config{")
	g.P("        Endpoints:   []string{endpoint},")
	g.P("        DialTimeout: 5 * time.Second,")
	g.P("    })")
	g.P("    if err != nil {")
	g.P("        return nil, err")
	g.P("    }")
	g.P("    return &", message.GoIdent.GoName, "EtcdServer{client: cli}, nil")
	g.P("}")

	g.P("func (s *", message.GoIdent.GoName, "EtcdServer) Serve(ctx context.Context, m *", message.GoIdent.GoName, ") error {")
	g.P("    // Логика сервера для работы с etcd")
	g.P("    return nil")
	g.P("}")
}

// getEtcdKeyTemplate получает значение etcd_key_template из опции сообщения
func getEtcdKeyTemplate(message *protogen.Message) string {
	opts := message.Desc.Options().(*descriptorpb.MessageOptions)
	if proto.HasExtension(opts, ipb.E_EtcdKeyParams) {
		keyTemplate := proto.GetExtension(opts, ipb.E_EtcdKeyParams).(string)
		return keyTemplate
	}
	return ""
}
