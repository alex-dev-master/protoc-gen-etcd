// Code generated by protoc-gen-etcd. DO NOT EDIT.
package proto

import (
	"context"
	"go.etcd.io/etcd/client/v3"
	"fmt"
	"time"
)

// UserEtcdClient предоставляет методы для работы с etcd
type UserEtcdClient struct {
	client *clientv3.Client
}

func NewUserEtcdClient(endpoint string) (*UserEtcdClient, error) {
	cli, err := clientv3.New(clientv3.Config{
		Endpoints:   []string{endpoint},
		DialTimeout: 5 * time.Second,
	})
	if err != nil {
		return nil, err
	}
	return &UserEtcdClient{client: cli}, nil
}
func (c *UserEtcdClient) Put(ctx context.Context, m *User) error {
	key := c.generateKey(m)
	_, err := c.client.Put(ctx, key, m.String())
	return err
}
func (c *UserEtcdClient) Get(ctx context.Context, id string) (*User, error) {
	key := fmt.Sprintf("/users/{id}", id)
	resp, err := c.client.Get(ctx, key)
	if err != nil {
		return nil, err
	}
	if len(resp.Kvs) == 0 {
		return nil, fmt.Errorf("ключ не найден")
	}
	return &User{ /* распарсить значение */ }, nil
}
func (c *UserEtcdClient) generateKey(m *User) string {
	return fmt.Sprintf("/users/{id}", m.Id)
}

// UserEtcdServer предоставляет методы сервера для работы с etcd
type UserEtcdServer struct {
	client *clientv3.Client
}

func NewUserEtcdServer(endpoint string) (*UserEtcdServer, error) {
	cli, err := clientv3.New(clientv3.Config{
		Endpoints:   []string{endpoint},
		DialTimeout: 5 * time.Second,
	})
	if err != nil {
		return nil, err
	}
	return &UserEtcdServer{client: cli}, nil
}
func (s *UserEtcdServer) Serve(ctx context.Context, m *User) error {
	// Логика сервера для работы с etcd
	return nil
}
